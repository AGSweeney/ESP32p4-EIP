<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>VL53L1x Status</title><style>* { box-sizing: border-box; }body { padding: 0; margin: 0; background-color: #f5f5f5; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }.navbar { background-color: #212529; padding: 15px 0; margin-bottom: 20px; }.navbar-nav { display: flex; flex-direction: row; list-style: none; margin: 0; padding: 0 20px; justify-content: flex-start; align-items: center; width: 100%; }.navbar-nav li { margin: 0 15px; }.navbar-nav a { color: #ffffff; text-decoration: none; font-weight: 500; padding: 8px 16px; border-radius: 4px; transition: background-color 0.2s; }.navbar-nav a:hover { background-color: rgba(255, 255, 255, 0.1); }.navbar-nav a.active { background-color: #007bff; }.navbar-nav li.sensor-nav-item { display: none; }.content-wrapper { padding: 20px; }.container { max-width: 800px; background: white; padding: 0; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin: 0 auto; overflow: hidden; }.page-header { background-color: #f8f9fa; padding: 20px 30px; border-bottom: 1px solid #dee2e6; }.page-header h1 { margin: 0; color: #212529; font-size: 1.75rem; font-weight: 700; text-transform: uppercase; }.page-content { padding: 30px; }.row { display: flex; flex-wrap: wrap; margin: 0 -10px; }.col-md-6 { flex: 0 0 50%; max-width: 50%; padding: 0 10px; }@media (max-width: 768px) { .col-md-6 { flex: 0 0 100%; max-width: 100%; } }.status-card { border: 1px solid #ddd; border-radius: 8px; padding: 0; margin-bottom: 20px; background-color: #fff; overflow: hidden; }.card-header { background-color: #f8f9fa; padding: 15px 20px; border-bottom: 1px solid #dee2e6; margin: 0; }.card-header h2, .card-header h3 { margin: 0; color: #212529; font-size: 1.25rem; font-weight: 600; }.card-body { padding: 20px; }.status-value { font-size: 24px; font-weight: bold; color: #007bff; }.distance-bar-container { margin-top: 20px; }.distance-bar-wrapper { position: relative; width: 100%; height: 40px; background-color: #e9ecef; border-radius: 4px; overflow: hidden; border: 1px solid #ced4da; }.distance-bar-fill { height: 100%; transition: width 0.3s ease, background-color 0.3s ease; border-radius: 4px; }.distance-bar-label { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: bold; color: #333; text-shadow: 0 0 3px rgba(255,255,255,0.8); pointer-events: none; z-index: 10; }.distance-bar-scale { display: flex; justify-content: space-between; margin-top: 5px; font-size: 11px; color: #666; }</style></head><body><nav class="navbar"><ul class="navbar-nav"><li><a href="index.html">Configuration</a></li><li><a href="status.html" class="active">VL53L1x</a></li><li><a href="inputassembly.html">T->O</a></li><li><a href="outputassembly.html">O->T</a></li><li><a href="ota.html">Firmware Update</a></li></ul></nav><div class="content-wrapper"><div class="container"><div class="page-header"><h1>VL53L1x Sensor Status</h1></div><div class="page-content"><div style="margin-bottom: 20px; padding: 12px; background-color: #f8f9fa; border-left: 4px solid #007bff; border-radius: 4px;"><p style="margin: 0; color: #495057; font-size: 14px; line-height: 1.6;"><strong>Real-Time Sensor Data:</strong> This page displays live distance measurements and sensor status from the VL53L1x time-of-flight sensor. Data updates automatically every 250ms. The distance range bar provides a visual representation of the current measurement relative to the configured maximum range. Status codes indicate measurement validity, with detailed error descriptions when issues are detected.</p></div><div class="status-card"><div class="card-header"><h3>Current Readings</h3></div><div class="card-body"><div class="row"><div class="col-md-6"><p><strong>Distance:</strong> <span class="status-value" id="distance">-</span> mm</p><p><strong>Status:</strong> <span id="status">-</span></p><p><strong>Ambient:</strong> <span id="ambient">-</span> kcps</p></div><div class="col-md-6"><p><strong>Signal per SPAD:</strong> <span id="sig_per_spad">-</span> kcps/SPAD</p><p><strong>Number of SPADs:</strong> <span id="num_spads">-</span></p></div></div></div></div><div class="status-card"><div class="card-header"><h3>Distance Range</h3></div><div class="card-body"><div class="distance-bar-container"><div class="distance-bar-wrapper"><div class="distance-bar-fill" id="distanceBarFill" style="width: 0%; background-color: #dc3545;"></div><div class="distance-bar-label" id="distanceBarLabel">- mm</div></div><div class="distance-bar-scale"><span id="scaleMin">0</span><span id="scaleMax">4000</span></div></div></div></div></div><footer style="text-align: center; padding: 20px 30px; border-top: 1px solid #dee2e6; color: #666; background-color: #f8f9fa;">OpENer Ethernet/IP for ESP32-P4 | Adam G Sweeney 11-15-2025</footer></div></div><script>let currentDistanceMode = 2;let maxDistance = 4000;function getStatusDescription(statusCode) {  const statusMap = {    0: 'Valid measurement',    1: 'Sigma failed (measurement uncertainty too high)',    2: 'Signal failed (signal too weak)',    3: 'Target out of range',    4: 'Out of bounds (signal failed)',    5: 'Range valid but wrapped',    6: 'Target out of range',    7: 'Wrap-around (target beyond max range)',    9: 'Range valid but wrapped',    10: 'Target out of range',    11: 'Range valid but wrapped',    12: 'Range valid but wrapped',    13: 'Range valid but wrapped',    255: 'Invalid/unknown status'  };  return statusMap[statusCode] || 'Unknown status code';}function lerp(start, end, t) {  return start + (end - start) * t;}function getGradientColor(value, max) {  if (value <= 0) return 'rgb(220, 53, 69)';  if (value >= max) return 'rgb(40, 167, 69)';  const ratio = value / max;  let r, g, b;  if (ratio < 0.5) {    const t = ratio * 2;    r = Math.round(lerp(220, 255, t));    g = Math.round(lerp(53, 193, t));    b = Math.round(lerp(69, 7, t));  } else {    const t = (ratio - 0.5) * 2;    r = Math.round(lerp(255, 40, t));    g = Math.round(lerp(193, 167, t));    b = Math.round(lerp(7, 69, t));  }  return 'rgb(' + r + ',' + g + ',' + b + ')';}function updateDistanceBar(distance, distanceMode) {  const maxDist = distanceMode === 1 ? 1300 : 4000;  maxDistance = maxDist;  currentDistanceMode = distanceMode;    document.getElementById('scaleMax').textContent = maxDist;    if (distance === undefined || distance === null || distance < 0) {    document.getElementById('distanceBarFill').style.width = '0%';    document.getElementById('distanceBarFill').style.backgroundColor = '#dc3545';    document.getElementById('distanceBarLabel').textContent = '- mm';    return;  }    const percentage = Math.min(100, (distance / maxDist) * 100);  const clampedDistance = Math.min(distance, maxDist);    document.getElementById('distanceBarFill').style.width = percentage + '%';  document.getElementById('distanceBarFill').style.backgroundColor = getGradientColor(clampedDistance, maxDist);  document.getElementById('distanceBarLabel').textContent = distance + ' mm';}function updateStatus() {  fetch('/api/status')    .then(r => {      if (!r.ok) {        throw new Error('HTTP ' + r.status);      }      return r.json();    })    .then(data => {      console.log('API data received:', data);      if (data.distance_mm !== undefined && data.distance_mm !== null) {        document.getElementById('distance').textContent = data.distance_mm;      } else {        document.getElementById('distance').textContent = '-';      }      if (data.status !== undefined && data.status !== null) {        if (data.status === 0) {          document.getElementById('status').textContent = 'Valid';        } else {          const description = getStatusDescription(data.status);          document.getElementById('status').textContent = 'Error (' + data.status + ') ' + description;        }      } else {        document.getElementById('status').textContent = '-';      }      if (data.ambient_kcps !== undefined && data.ambient_kcps !== null) {        document.getElementById('ambient').textContent = data.ambient_kcps;      } else {        document.getElementById('ambient').textContent = '-';      }      if (data.sig_per_spad_kcps !== undefined && data.sig_per_spad_kcps !== null) {        document.getElementById('sig_per_spad').textContent = data.sig_per_spad_kcps;      } else {        document.getElementById('sig_per_spad').textContent = '-';      }      if (data.num_spads !== undefined && data.num_spads !== null) {        document.getElementById('num_spads').textContent = data.num_spads;      } else {        document.getElementById('num_spads').textContent = '-';      }            const distanceMode = data.distance_mode !== undefined ? data.distance_mode : 2;      updateDistanceBar(data.distance_mm, distanceMode);    })    .catch(err => {      console.error('Status update error:', err);    });}function updateNavigationBar() {  fetch('/api/sensor/enabled')    .then(r => {      if (!r.ok) throw new Error('HTTP ' + r.status);      return r.json();    })    .then(data => {      const navItems = document.querySelectorAll('nav li.sensor-nav-item');      navItems.forEach(item => {        if (item) {          item.style.display = data.enabled ? 'block' : 'none';        }      });    })    .catch(err => {      console.error('Failed to update navigation bar:', err);    });}function initPage() {  updateStatus();  setInterval(updateStatus, 250);  updateNavigationBar();}if (document.readyState === 'loading') {  document.addEventListener('DOMContentLoaded', initPage);} else {  initPage();}</script></body></html>